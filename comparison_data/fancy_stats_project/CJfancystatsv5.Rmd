---
title: "CJ analysis of decision data"
output: html_document
---

```{r  setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#rm(list = ls())
require(psy)
require(psych)
require(dplyr)
require(CTT)
require(cocor)
require(reshape2)
require(QuantPsyc)
library(sirt)
library(ggpubr)
require(Hmisc)

library(car)
library(ggplot2)
library(nlme)
#library(rjags)


# Create a mode function.
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}
```





## Statistics 2 NZJES 2020: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('NZJES_mathsdecisions.csv', header=T, stringsAsFactors=F)
#decisions <- read.csv(file.choose(), header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))


```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
sum(rangeS$total)/2
```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
#SEE_experts <- scores[scores$individual!=108,c(1,4,5)] #needed for SEE 2015 analysis below
```










###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```



Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column
#i<-1
      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      #print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```


### Statistics 2 NZJES validity


```{r echo=FALSE}

NZJESvalid1 <- read.csv('NZJES_GPA.csv', header=T, stringsAsFactors=F)
NZJESvalid2 <- merge(NZJESvalid1, scores)

#regression with theta
NZJESstatstheta <- lm(NZJESvalid2$theta ~ NZJESvalid2$overall.gpa + NZJESvalid2$eng.gpa )
summary(NZJESstatstheta)
lm.beta(NZJESstatstheta)

#regression with raw
NZJESstatsraw <- lm(NZJESvalid2$raw ~ NZJESvalid2$overall.gpa + NZJESvalid2$eng.gpa )
summary(NZJESstatsraw)
lm.beta(NZJESstatsraw)

```




## Writing NZJES 2020: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('NZJES_engdecisions.csv', header=T, stringsAsFactors=F)
#decisions <- read.csv(file.choose(), header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))


```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
sum(rangeS$total)/2
```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
#SEE_experts <- scores[scores$individual!=108,c(1,4,5)] #needed for SEE 2015 analysis below
```










###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```



Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column
#i<-1
      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)
  if (length(raw1) == length(raw2)) { #skip loop if different number of candidates in each rank
      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))
  } else {i <- i-1}
      


      #print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```


### Writing NZJES validity


```{r echo=FALSE}

NZJESvalid1 <- read.csv('NZJES_GPA.csv', header=T, stringsAsFactors=F)

NZJESvalid2 <- merge(NZJESvalid1, scores)

#regression with theta
NZJESstatstheta <- lm(NZJESvalid2$theta ~ NZJESvalid2$overall.gpa + NZJESvalid2$eng.gpa )
summary(NZJESstatstheta)
lm.beta(NZJESstatstheta)

#regression with raw
NZJESstatsraw <- lm(NZJESvalid2$raw ~ NZJESvalid2$overall.gpa + NZJESvalid2$eng.gpa )
summary(NZJESstatsraw)
lm.beta(NZJESstatsraw)

```



## CHEMISTRY AIE 2014: peer analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('AIE_PEERDECISIONS.csv', header=T, stringsAsFactors=F)
#decisions <- read.csv(file.choose(), header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))


```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
sum(rangeS$total)
```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```










###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```



Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column
#i<-1
      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      #print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```

### validity analysis chemsitry


```{r echo=FALSE}

chemistry <- read.csv('AIE_data.csv', header=T, stringsAsFactors=F)
chemistry2 <- merge(chemistry,scores)

#theta validity with teachers
cor(chemistry2$teachers,chemistry2$theta)
#raw validity with teachers
cor(chemistry2$teachers,chemistry2$raw)
cor(chemistry2$theta,chemistry2$raw)

#theta validity with marks
cor(chemistry2$theta,chemistry2$mark)
#raw validity with marks
cor(chemistry2$raw,chemistry2$mark)
cor(chemistry2$raw,chemistry2$theta)

chemistry3 <- chemistry2[chemistry2$mean!=-99,]
#theta validity with prior
cor(chemistry3$theta,chemistry3$mean)
#raw validity with prior
cor(chemistry3$raw,chemistry3$mean)

#regression with theta
chemregtheta <- lm(chemistry2$theta ~ chemistry2$q1 + chemistry2$q2 + chemistry2$q3 + chemistry2$q4 )
summary(chemregtheta)
lm.beta(chemregtheta)

#regression with raw
chemregraw <- lm(chemistry2$raw ~ chemistry2$q1 + chemistry2$q2 + chemistry2$q3 + chemistry2$q4 )
summary(chemregraw)
lm.beta(chemregraw)



```





## FRACTIONS PME 2012: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('PMEfractionsdecisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))


```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
sum(rangeS$total)
```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
SEE_experts <- scores[scores$individual!=108,c(1,4,5)] #needed for SEE 2015 analysis below
#because the expert judgements in SEE 2015 are in fact the judgements from PME
```

Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions,jq1)
colnames(jq)[8:9] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[10:11] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```


Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2)) 
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)
jq_fractions1 <- jq[jq$probTheta>.7,]

expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)



jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



Pairings measure
```{r echo=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_fractions1 <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_fractions1)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_fractions1 <- jq_fractions1[order(jq_fractions1$raw_diff),]

jq_fractions1 <- jq_fractions1[134:400,]

#write.csv(jq_fractions1,"PMEfractionsdecisionsFARPAIRINGSONLY.csv")

```  




###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```



Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop

#writefractions <- data_frame(theta1=modg12$theta.x,theta2=modg12$theta.y,raw1=raw1,raw2=raw2)
#write.csv(writefractions,"PMEfractionsPlot.csv")
#plot(writefractions$theta1,writefractions$theta2)
#plot(writefractions$raw1,writefractions$raw2)

```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```


```{r include=FALSE}
achievement <- read.csv('PMEfractionsachievement.csv', header=T)
df <- merge(achievement,scores)
SEE_achievement <- achievement[achievement$individual!=108,] #needed for SEE 2015 analysis below
```


### older students: theta
```{r echo=FALSE}
older1 <- lm(df$theta ~ df$grade + df$Lev.Dist)
summary(older1)
lm.beta(older1)
```



### older students: raw
```{r echo=FALSE}
older2 <- lm(df$raw ~ df$grade + df$Lev.Dist)
summary(older2)
lm.beta(older2)
```


### younger students: theta
```{r echo=FALSE}
younger1 <- lm(df$theta ~ df$level + df$Lev.Dist)
summary(younger1)
lm.beta(younger1)
```


### younger students: raw
```{r echo=FALSE}
younger2 <- lm(df$raw ~ df$level + df$Lev.Dist)
summary(younger2)
lm.beta(younger2)
```

### PME fractions with close pairings removed

```{r include=FALSE}

decisions <- read.csv('PMEfractionsdecisionsFARPAIRINGSONLY.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```

Total judgements =
```{r echo=FALSE}
nrow(decisions)
```

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)

```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
SEE_experts <- scores[scores$individual!=108,c(1,4,5)] #needed for SEE 2015 analysis below
```




Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```


## IJRUME STATS: analysis   {.tabset}
Using original thetas and raw scores; no module scores available


```{r include=FALSE}

IJRUMEachieve <- read.csv('IJRUMEstatsachieve.csv', header=T, stringsAsFactors=F)[,c(1,6,7)]

```


```{r include=FALSE}

decisions <- read.csv('IJRUMEstatsdecisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)

```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```

Correlation of theta and RPASS
```{r echo=FALSE}
df <- merge(IJRUMEachieve,scores)
c1 <- cor.test(df$theta,df$perc_RPASS)
c1
c1  <- c1$estimate
#cor(df$theta,df$perc_RPASS)/sqrt(.539*.745)
 #cronbach's alpha for RPASS and SSR
```



Correlation of raw andRPASS
```{r echo=FALSE}

c2 <- cor.test(df$perc_RPASS,df$raw)
c2
c2  <- c2$estimate

c3 <- cor(df$theta,df$raw)
cocor.dep.groups.overlap(c1,c2,c3,nrow(df))@steiger1980
```




## IJRUME CALCULUS: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('IJRUMEcalculusdecisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)

```


```{r BTM2, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)

```


Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```



```{r include=FALSE}
achievement <- read.csv('IJRUMEcalculusachievement.csv', header=T)
df <- merge(achievement,scores)

```


## Correlation analysis

Correlation of CJ and raw
```{r echo=FALSE}

c3 <- cor.test(df$CJ_all_decisions,df$raw)
c3
c3 <- c3$estimate
```




Correlation of CJ and CCI
```{r echo=FALSE}

c1 <- cor.test(df$CJ_all_decisions,df$cci)
c1
c1  <- c1$estimate

```



Correlation of raw and CCI
```{r echo=FALSE}

c2 <- cor.test(df$cci,df$raw)
c2
c2  <- c2$estimate

cocor.dep.groups.overlap(c2,c1,c3,nrow(df))@steiger1980
```



Correlation of CJ and A-level
```{r echo=FALSE}
df1 <- df[df$Alevel>0,]

a1 <- cor.test(df1$CJ_all_decisions,df1$Alevel, method="spearman")
a1
a1  <- a1$estimate

```



Correlation of raw and A-level
```{r echo=FALSE}

a2 <- cor.test(df1$raw,df1$Alevel, method="spearman")
a2
a2  <- a2$estimate

a3 <- cor.test(df1$raw,df1$CJ_all_decisions)$estimate

cocor.dep.groups.overlap(a1,a2,a3,nrow(df1))@steiger1980

```




## IJRUME ALGEBRA: analysis  {.tabset}
<!-- CHUNKSTEMNAME: IJRUME ALGEBRA  -->


```{r include=FALSE}

decisions <- read.csv('IJRUMEalgebradecisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)


```


```{r BTM2b, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```



```{r include=FALSE}
achievement <- read.csv('IJRUMEalgebraachievement.csv', header=T)
df <- merge(achievement,scores)

```


### Correlation analysis

Correlation of CJ and raw
```{r echo=FALSE}

c3 <- cor.test(df$CJ,df$raw)
c3
c3 <- c3$estimate
```


Correlation of CJ and ICCAMS
```{r echo=FALSE}

c1 <- cor.test(df$CJ,df$ICCAMS)
c1
c1  <- c1$estimate

```



Correlation of raw and ICCAMS
```{r echo=FALSE}

c2 <- cor.test(df$ICCAMS,df$raw)
c2
c2  <- c2$estimate

cocor.dep.groups.overlap(c2,c1,c3,nrow(df))@steiger1980
```





Correlation of CJ and maths level
```{r echo=FALSE}

l1 <- cor.test(df$CJ,df$Maths_level_recoded, method="spearman")
l1
l1  <- l1$estimate

```



Correlation of raw and ICCAMS
```{r echo=FALSE}

l2 <- cor.test(df$Maths_level_recoded,df$raw, method="spearman")
l2
l2  <- l2$estimate

cocor.dep.groups.overlap(l2,l1,c3,nrow(df))@steiger1980

```




## CALCULUS PEER ASSESSMENT SHE2014: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('SHE2014decisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```

### expert1
```{r , include=FALSE}
#### Fit B-T ####
expert1 <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)[decisions$group=="expert1",]
expert1$id1 <- factor(expert1$id1,levels=players)
expert1$id2 <- factor(expert1$id2,levels=players)
modexpert1 <- sirt::btm(expert1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge[decisions$group=="expert1"]))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions[decisions$group=="expert1",] %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions[decisions$group=="expert1",]$Candidate.Chosen,decisions[decisions$group=="expert1",]$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)


```


SSR=
```{r echo=FALSE}
round(modexpert1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- modexpert1$effects$N1/modexpert1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(modexpert1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions[decisions$group=="expert1",],jq1)
colnames(jq)[5:6] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[7:8] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)
jq_SHEexpert1 <- jq[jq$probTheta>.7,]
write.csv(jq_SHEexpert1,"SHE2014_expert1CLOSEPAIRINGSREMOVED.csv")

expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  


```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[406:1217,]

#write.csv(jq_trimmed,"SHE2014_expert1CLOSEPAIRINGSREMOVED.csv")

```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


### expert2
```{r , include=FALSE}
expert2 <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)[decisions$group=="expert2",]
expert2$id1 <- factor(expert2$id1,levels=players)
expert2$id2 <- factor(expert2$id2,levels=players)
modexpert2 <- sirt::btm(expert2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )

```

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge[decisions$group=="expert2"]))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions[decisions$group=="expert2",] %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions[decisions$group=="expert2",]$Candidate.Chosen,decisions[decisions$group=="expert2",]$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


SSR=
```{r echo=FALSE}
round(modexpert2$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- modexpert2$effects$N1/modexpert2$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(modexpert2$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```


Judgement quality, theta then raw (then raw matches)
```{r include=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions[decisions$group=="expert2",],jq1)
colnames(jq)[5:6] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[7:8] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[406:1217,]

write.csv(jq_trimmed,"SHE2014_expert2CLOSEPAIRINGSREMOVED.csv")

```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


### novice
```{r , include=FALSE}
novice <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)[decisions$group=="novice",]
novice$id1 <- factor(novice$id1,levels=players)
novice$id2 <- factor(novice$id2,levels=players)
modnovice <- sirt::btm(novice , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
```


Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge[decisions$group=="novice"]))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions[decisions$group=="novice",] %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions[decisions$group=="novice",]$Candidate.Chosen,decisions[decisions$group=="novice",]$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


SSR=
```{r echo=FALSE}
round(modnovice$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- modnovice$effects$N1/modnovice$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(modnovice$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(novice,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

### peer1
```{r , include=FALSE}

peer1 <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)[decisions$group=="peer1",]
peer1$id1 <- factor(peer1$id1,levels=players)
peer1$id2 <- factor(peer1$id2,levels=players)
modpeer1 <- sirt::btm(peer1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )

```

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge[decisions$group=="peer1"]))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions[decisions$group=="peer1",] %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions[decisions$group=="peer1",]$Candidate.Chosen,decisions[decisions$group=="peer1",]$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


SSR=
```{r echo=FALSE}
round(modpeer1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- modpeer1$effects$N1/modpeer1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(modpeer1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```




Judgement quality, theta then raw (then raw matches)
```{r include=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions[decisions$group=="peer1",],jq1)
colnames(jq)[5:6] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[7:8] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[401:1200,]

#write.csv(jq_trimmed,"SHE2014_peer1CLOSEPAIRINGSREMOVED.csv")

```  




```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[406:1217,]

#write.csv(jq_trimmed,"SHE2014_peer1CLOSEPAIRINGSREMOVED.csv")

```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

### peer2
```{r , include=FALSE}
peer2 <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)[decisions$group=="peer2",]
peer2$id1 <- factor(peer2$id1,levels=players)
peer2$id2 <- factor(peer2$id2,levels=players)
modpeer2 <- sirt::btm(peer2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )


```

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge[decisions$group=="peer2"]))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions[decisions$group=="peer2",] %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions[decisions$group=="peer2",]$Candidate.Chosen,decisions[decisions$group=="peer2",]$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


SSR=
```{r echo=FALSE}
round(modpeer2$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- modpeer2$effects$N1/modpeer2$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(modpeer2$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)
```


Judgement quality, theta then raw (then raw matches)
```{r include=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions[decisions$group=="peer2",],jq1)
colnames(jq)[5:6] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[7:8] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[404:1210,]

#write.csv(jq_trimmed,"SHE2014_peer2CLOSEPAIRINGSREMOVED.csv")

```  




```{r include=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_trimmed <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_trimmed)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_trimmed <- jq_trimmed[order(jq_trimmed$raw_diff),]

jq_trimmed <- jq_trimmed[401:1200,]

#write.csv(jq_trimmed,"SHE2014_peer2CLOSEPAIRINGSREMOVED.csv")

```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

### Pearson correlations
```{r echo=FALSE}
rawexpert1 <- modexpert1$effects$N1/modexpert1$effects$Ntot
scoresexpert1 <- cbind(modexpert1$effects[,c(1,3,4,10)],rawexpert1)
colnames(scoresexpert1) <- c("individual", "Ntotexpert1", "Nexpert1", "thetaexpert1", "rawexpert1")

rawexpert2 <- modexpert2$effects$N1/modexpert2$effects$Ntot
scoresexpert2 <- cbind(modexpert2$effects[,c(1,3,4,10)],rawexpert2)
colnames(scoresexpert2) <- c("individual", "Ntotexpert2", "Nexpert2", "thetaexpert2", "rawexpert2")

rawnovice <- modnovice$effects$N1/modnovice$effects$Ntot
scoresnovice <- cbind(modnovice$effects[,c(1,3,4,10)],rawnovice)
colnames(scoresnovice) <- c("individual", "Ntotnovice", "Nnovice", "thetanovice", "rawnovice")

rawpeer1 <- modpeer1$effects$N1/modpeer1$effects$Ntot
scorespeer1 <- cbind(modpeer1$effects[,c(1,3,4,10)],rawpeer1)
colnames(scorespeer1) <- c("individual", "Ntotpeer1", "Npeer1", "thetapeer1", "rawpeer1")

rawpeer2 <- modpeer2$effects$N1/modpeer2$effects$Ntot
scorespeer2 <- cbind(modpeer2$effects[,c(1,3,4,10)],rawpeer2)
colnames(scorespeer2) <- c("individual", "Ntotpeer2", "Npeer2", "thetapeer2", "rawpeer2")

scores <- merge(scoresexpert1,scoresexpert2)
scores <- merge(scores,scoresnovice)
scores <- merge(scores,scorespeer1)
scores <- merge(scores,scorespeer2)

thetameanexpert <- (scores$thetaexpert1 + scores$thetaexpert2) / 2
rawmeanexpert <- (scores$rawexpert1 + scores$rawexpert2) / 2
thetameanpeer <- (scores$thetapeer1 + scores$thetapeer2) / 2
rawmeanpeer <- (scores$rawpeer1 + scores$rawpeer2) / 2

scores <- cbind(scores,thetameanexpert,rawmeanexpert,thetameanpeer, rawmeanpeer)

cpearson <- round(cor(scores[,c(4,5,8,9,12,13,16,17,20,21,22,23,24,25)]),3)
cpearson


writecalculus <- data_frame(experttheta1=modexpert1$effects$theta,experttheta2=modexpert2$effects$theta,expertraw1=rawexpert1,expertraw2=rawexpert2,peertheta1=modpeer1$effects$theta,peertheta2=modpeer2$effects$theta,peerraw1=rawpeer1,peerraw2=rawpeer2)
write.csv(writecalculus,"SHE2014Plot.csv")
plot(writecalculus$experttheta1,writecalculus$experttheta2)
plot(writecalculus$expertraw1,writecalculus$expertraw2)
plot(writecalculus$peertheta1,writecalculus$peertheta2)
plot(writecalculus$peerraw1,writecalculus$peerraw2)

```


Correlation tests: experts
```{r echo=FALSE}

IRthetaexpert <- cpearson[1,3]
IRrawexpert <- cpearson[2,4]
cocor.indep.groups(IRthetaexpert, IRrawexpert, nrow(scores), nrow(scores))@fisher1925

```


Correlation tests: peers
```{r echo=FALSE}

IRthetapeer <- cpearson[7,9]
IRrawpeer <- cpearson[8,10]
cocor.indep.groups(IRthetapeer, IRrawpeer, nrow(scores), nrow(scores))@fisher1925

```


Correlation tests: mean expert, mean peer
```{r echo=FALSE}

IRthetameans <- cpearson[11,13]
IRrawmeans <- cpearson[12,14]
cocor.indep.groups(IRthetameans, IRrawmeans, nrow(scores), nrow(scores))@fisher1925

```


Spearman correlations
```{r echo=FALSE}


cspearman <- round(cor(scores[,c(4,5,8,9,12,13,16,17,20,21,22,23,24,25)], method="spearman"),3)
cspearman

```


Mean module scores
```{r echo=FALSE}

achievement <- read.csv('SHE2014achievement.csv', header=T)
scoresandachievement <- merge(scores, achievement)

modulescores <- cor(scoresandachievement[,26:30], use="pairwise.complete.obs")
meanmodulescore <- round(mean(c(modulescores[2:5,1],modulescores[3:5,2],modulescores[4:5,3],modulescores[5,4])),3)
meanmodulescore
```

Expert and peer mean module score correlations (theta and raw)
```{r echo=FALSE}

expertmodulecorrel <- cor(scoresandachievement[,c(22,23,26:30)], use="pairwise.complete.obs")
expertcorreltheta <- expertmodulecorrel[3:7,1]
expertmeancorreltheta <- round(mean(expertcorreltheta),3)
expertcorreltheta
expertmeancorreltheta

expertcorrelraw <- expertmodulecorrel[3:7,2]
expertmeancorrelraw <- round(mean(expertcorrelraw),3)
expertcorrelraw
expertmeancorrelraw

wilcox1 <- wilcox.test(expertcorreltheta,expertcorrelraw, paired=TRUE)
zstat1 <-qnorm(wilcox1$p.value/2)
wilcox1
zstat1

peermodulecorrel <- cor(scoresandachievement[,c(24:30)], use="pairwise.complete.obs")
peercorreltheta <- peermodulecorrel[3:7,1]
peermeancorreltheta <- round(mean(peercorreltheta),3)
peercorreltheta
peermeancorreltheta

peercorrelraw <- peermodulecorrel[3:7,2]
peermeancorrelraw <- round(mean(peercorrelraw),3)
peercorrelraw
peermeancorrelraw

wilcox2 <- wilcox.test(peercorreltheta,peercorrelraw, paired=TRUE)
zstat2 <-qnorm(wilcox2$p.value/2)
wilcox2
zstat2


```


Novice and mean expert correlations
```{r echo=FALSE}

expertnovicetheta <- cor(scoresandachievement$thetameanexpert,scoresandachievement$thetanovice)
expertnoviceraw <- cor(scoresandachievement$rawmeanexpert,scoresandachievement$rawnovice)
round(expertnovicetheta,3)
round(expertnoviceraw,3)

cocor.indep.groups(expertnovicetheta, expertnoviceraw, nrow(scoresandachievement), nrow(scoresandachievement))@fisher1925

```


File size and mean expert (theta and raw)
```{r echo=FALSE}

#ggqqplot(scoresandachievement$filesize)
shapiro.test(scoresandachievement$filesize)

expertfilesizetheta <- cor(scoresandachievement$thetameanexpert,scoresandachievement$filesize, method="spearman")
expertfilesizeraw <- cor(scoresandachievement$rawmeanexpert,scoresandachievement$filesize, method="spearman")
expertthetaraw <- cor(scoresandachievement$rawmeanexpert,scoresandachievement$thetameanexpert)

round(expertfilesizetheta,3)
round(expertfilesizeraw,3)
round(expertthetaraw,3)

cocor.dep.groups.overlap(expertfilesizetheta,expertfilesizeraw,expertthetaraw,nrow(scoresandachievement))@steiger1980

```



File size and mean novice (theta and raw)
```{r echo=FALSE}


novicefilesizetheta <- cor(scoresandachievement$thetameanpeer,scoresandachievement$filesize, method="spearman")
novicefilesizeraw <- cor(scoresandachievement$rawmeanpeer,scoresandachievement$filesize, method="spearman")
novicethetaraw <- cor(scoresandachievement$rawmeanpeer,scoresandachievement$thetameanpeer)

round(novicefilesizetheta,3)
round(novicefilesizeraw,3)
round(novicethetaraw,3)

cocor.dep.groups.overlap(novicefilesizetheta,novicefilesizeraw,novicethetaraw,nrow(scoresandachievement))@steiger1980

```



File size and experts vs novices: theta then raw
```{r echo=FALSE}


cocor.dep.groups.overlap(novicefilesizetheta,expertfilesizetheta,expertnovicetheta,nrow(scoresandachievement))@steiger1980

cocor.dep.groups.overlap(novicefilesizeraw,expertfilesizeraw,expertnoviceraw,nrow(scoresandachievement))@steiger1980

```

### SHE2014 reliabilities with close pairings removed {.tabset}


```{r include=FALSE}

re_expert1 <- read.csv('SHE2014_expert1CLOSEPAIRINGSREMOVED.csv', header=T, stringsAsFactors=F)
re_expert2 <- read.csv('SHE2014_expert2CLOSEPAIRINGSREMOVED.csv', header=T, stringsAsFactors=F)
re_peer1 <- read.csv('SHE2014_peer1CLOSEPAIRINGSREMOVED.csv', header=T, stringsAsFactors=F)
re_peer2 <- read.csv('SHE2014_peer2CLOSEPAIRINGSREMOVED.csv', header=T, stringsAsFactors=F)

```


EXPERT 1
```{r include=FALSE}

decisions <- re_expert1
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresexpert1 <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scoresexpert1$theta,scoresexpert1$raw)

```



EXPERT 2
```{r include=FALSE}

decisions <- re_expert2
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresexpert2 <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scoresexpert2$theta,scoresexpert2$raw)

```


Expert inter-rater
```{r echo=FALSE}
thetaexpert <- cor(scoresexpert1$theta,scoresexpert2$theta)
rawexpert <- cor(scoresexpert1$raw,scoresexpert2$raw)
thetaexpert
rawexpert
cocor.indep.groups(thetaexpert, rawexpert, nrow(scoresexpert1), nrow(scoresexpert2))@fisher1925
```


PEER 1
```{r include=FALSE}

decisions <- re_peer1
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scorespeer1 <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scorespeer1$theta,scorespeer1$raw)

```



PEER 2
```{r include=FALSE}

decisions <- re_peer2
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```



Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scorespeer2 <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scorespeer2$theta,scorespeer2$raw)

```


Peer inter-rater
```{r echo=FALSE}
#thetapeer <- cor(scorespeer1$theta,scorespeer2$theta)
#rawepeer <- cor(scorespeer1$raw,scorespeer2$raw)
#thetapeer
#rawepeer
#cocor.indep.groups(thetapeer, rawepeer, nrow(scorespeer1), nrow(scorespeer2))@fisher1925
```


## IJSME 2014: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('IJSME2014.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
bowland3 <- decisions[decisions$Session=="Bowland030211data",1:3]
bowland7 <- decisions[decisions$Session=="Bowland070211data",1:3]
gcse3 <- decisions[decisions$Session=="GCSE030211data",1:3]
gcse7 <- decisions[decisions$Session=="GCSE070211data",1:3]
validitygcse <- read.csv('IJSME2014_GCSE.csv', header=T)
validitybowland <- read.csv('IJSME2014_bowland.csv', header=T)

```

### IJSME 2014: GCSE 030211   {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(gcse3$Candidate.Chosen,gcse3$Candidate.Not.Chosen))
length(unique(gcse3$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = gcse3 %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(gcse3$Candidate.Chosen,gcse3$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=gcse3$Candidate.Chosen, id2=gcse3$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawgcse3 <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawgcse3==1)
zeros <- sum(rawgcse3==0)
ones
zeros
(ones+zeros)/length(rawgcse3)
scoresgcse3 <- cbind(mod1$effects[,c(1,3,4,10)],rawgcse3)
cor(scoresgcse3$theta,scoresgcse3$raw)
```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresgcse3[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresgcse3[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


### IJSME 2014: GCSE 070211   {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(gcse7$Candidate.Chosen,gcse7$Candidate.Not.Chosen))
length(unique(gcse7$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = gcse7 %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(gcse7$Candidate.Chosen,gcse7$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=gcse7$Candidate.Chosen, id2=gcse7$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawgcse7 <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawgcse7==1)
zeros <- sum(rawgcse7==0)
ones
zeros
(ones+zeros)/length(rawgcse7)
scoresgcse7 <- cbind(mod1$effects[,c(1,3,4,10)],rawgcse7)
cor(scoresgcse7$theta,scoresgcse7$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresgcse7[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresgcse7[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Inter-rater, theta then raw
```{r echo=FALSE}
gcsecortheta <- cor(scoresgcse7$theta,scoresgcse3$theta)
gcsecorraw <- cor(scoresgcse7$raw,scoresgcse3$raw)
gcsecortheta
gcsecorraw

cocor.indep.groups(gcsecortheta, gcsecorraw, nrow(scoresgcse7), nrow(scoresgcse7))@fisher1925
```


### GCSE Validity, theta then raw
```{r echo=FALSE}

gcsemeans <- data.frame(ID = scoresgcse3$individual, thetamean = rowMeans(cbind(scoresgcse3$theta,scoresgcse7$theta)), rawmean = rowMeans(cbind(scoresgcse3$rawgcse3,scoresgcse7$rawgcse7)))
 
validitygcse2 <- merge(validitygcse,gcsemeans)

validitygcsetheta <- cor(validitygcse2$numericgrade,validitygcse2$thetamean, method="spearman")
validitygcseraw <- cor(validitygcse2$numericgrade,validitygcse2$rawmean, method="spearman")

validitygcsetheta
validitygcseraw

cocor.dep.groups.overlap(validitygcsetheta,validitygcseraw,cor(validitygcse2$rawmean,validitygcse2$thetamean),nrow(validitygcse2))@steiger1980

```


### IJSME 2014: Bowland 030211 {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(bowland3$Candidate.Chosen,bowland3$Candidate.Not.Chosen))
length(unique(bowland3$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = bowland3 %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(bowland3$Candidate.Chosen,bowland3$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=bowland3$Candidate.Chosen, id2=bowland3$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawbowland3 <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawbowland3==1)
zeros <- sum(rawbowland3==0)
ones
zeros
(ones+zeros)/length(rawbowland3)
scoresbowland3 <- cbind(mod1$effects[,c(1,3,4,10)],rawbowland3)
cor(scoresbowland3$theta,scoresbowland3$raw)
```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresbowland3[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresbowland3[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


### IJSME 2014: Bowland 070211 {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(bowland7$Candidate.Chosen,bowland7$Candidate.Not.Chosen))
length(unique(bowland7$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = bowland7 %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(bowland7$Candidate.Chosen,bowland7$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=bowland7$Candidate.Chosen, id2=bowland7$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawbowland7 <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawbowland7==1)
zeros <- sum(rawbowland7==0)
ones
zeros
(ones+zeros)/length(rawbowland7)
scoresbowland7 <- cbind(mod1$effects[,c(1,3,4,10)],rawbowland7)
cor(scoresbowland7$theta,scoresbowland7$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresbowland7[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresbowland7[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

Inter-rater, theta then raw
```{r echo=FALSE}
bowlandcortheta <- cor(scoresbowland7$theta,scoresbowland3$theta)
bowlandcorraw <- cor(scoresbowland7$raw,scoresbowland3$raw)
bowlandcortheta
bowlandcorraw

cocor.indep.groups(bowlandcortheta, bowlandcorraw, nrow(scoresbowland7), nrow(scoresbowland7))@fisher1925
```


### BOWLAND Validity, theta then raw
```{r echo=FALSE}

bowlandmeans <- data.frame(ID = scoresbowland3$individual, thetamean = rowMeans(cbind(scoresbowland3$theta,scoresbowland7$theta)), rawmean = rowMeans(cbind(scoresbowland3$rawbowland3,scoresbowland7$rawbowland7)))
 
validitybowland2 <- merge(validitybowland,bowlandmeans)

validitybowlandtheta <- cor(validitybowland2$total.score,validitybowland2$thetamean, method="pearson")
validitybowlandraw <- cor(validitybowland2$total.score,validitybowland2$rawmean, method="pearson")

validitybowlandtheta
validitybowlandraw

cocor.dep.groups.overlap(validitybowlandtheta,validitybowlandraw,cor(validitybowland2$rawmean,validitybowland2$thetamean),nrow(validitybowland2))@steiger1980

```



## ESM 2015  {.tabset}


```{r include=FALSE}

decisions250 <- read.csv('ESM2015_250.csv', header=T, stringsAsFactors=F)
decisionsALL <- read.csv('ESM2015_ALL.csv', header=T, stringsAsFactors=F)
validityESM <- read.csv('ESM2015_achievement.csv', header=T)

```

### ESM 2015: All judgements  {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(decisionsALL$Candidate.Chosen,decisionsALL$Candidate.Not.Chosen))
length(unique(decisionsALL$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisionsALL %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisionsALL$Candidate.Chosen,decisionsALL$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisionsALL$Candidate.Chosen, id2=decisionsALL$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawdecisionsALL <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawdecisionsALL==1)
zeros <- sum(rawdecisionsALL==0)
ones
zeros
(ones+zeros)/length(rawdecisionsALL)
scoresdecisionsALL <- cbind(mod1$effects[,c(1,3,4,10)],rawdecisionsALL)
cor(scoresdecisionsALL$theta,scoresdecisionsALL$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresdecisionsALL[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresdecisionsALL[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisionsALL$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisionsALL,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Validity, for marks and GCSE grade (theta then raw)
```{r echo=FALSE}


validityESM_ALL <- merge(scoresdecisionsALL,validityESM)

#marks
validityESM_ALLtheta <- cor(validityESM_ALL$Mark,validityESM_ALL$theta, method="pearson")
validityESM_ALLraw <- cor(validityESM_ALL$Mark,validityESM_ALL$rawdecisionsALL, method="pearson")

validityESM_ALLtheta
validityESM_ALLraw

cocor.dep.groups.overlap(validityESM_ALLtheta,validityESM_ALLraw,cor(validityESM_ALL$Mark,validityESM_ALL$theta),nrow(validityESM_ALL))@steiger1980

#predicted grades
validityESM_ALLtheta2 <- cor(validityESM_ALL$predictedgrade,validityESM_ALL$theta, method="pearson")
validityESM_ALLraw2 <- cor(validityESM_ALL$predictedgrade,validityESM_ALL$rawdecisionsALL, method="pearson")

validityESM_ALLtheta2
validityESM_ALLraw2

cocor.dep.groups.overlap(validityESM_ALLtheta2,validityESM_ALLraw2,cor(validityESM_ALL$Mark,validityESM_ALL$theta),nrow(validityESM_ALL))@steiger1980

```


### ESM 2015: 250 judgements


Number of judges =
```{r echo=FALSE}
players <- unique(c(decisions250$Candidate.Chosen,decisions250$Candidate.Not.Chosen))
length(unique(decisions250$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions250 %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions250$Candidate.Chosen,decisions250$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions250$Candidate.Chosen, id2=decisions250$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawdecisions250 <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawdecisions250==1)
zeros <- sum(rawdecisions250==0)
ones
zeros
(ones+zeros)/length(rawdecisions250)
scoresdecisions250 <- cbind(mod1$effects[,c(1,3,4,10)],rawdecisions250)
cor(scoresdecisions250$theta,scoresdecisions250$raw)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresdecisions250[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scoresdecisions250[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions250$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions250,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Validity, for marks and GCSE grade (theta then raw)
```{r echo=FALSE}


validityESM_subset <- merge(scoresdecisions250,validityESM)

#marks
validityESM_subsettheta <- cor(validityESM_subset$Mark,validityESM_subset$theta, method="pearson")
validityESM_subsetraw <- cor(validityESM_subset$Mark,validityESM_subset$rawdecisions250, method="pearson")

validityESM_subsettheta
validityESM_subsetraw

cocor.dep.groups.overlap(validityESM_subsettheta,validityESM_subsetraw,cor(validityESM_subset$Mark,validityESM_subset$theta),nrow(validityESM_subset))@steiger1980


#predicted grades
validityESM_subsettheta2 <- cor(validityESM_subset$predictedgrade,validityESM_subset$theta, method="pearson")
validityESM_subsetraw2 <- cor(validityESM_subset$predictedgrade,validityESM_subset$rawdecisions250, method="pearson")

validityESM_subsettheta2
validityESM_subsetraw2

cocor.dep.groups.overlap(validityESM_subsettheta2,validityESM_subsetraw2,cor(validityESM_subset$Mark,validityESM_subset$theta),nrow(validityESM_subset))@steiger1980


```
Inter-rater reliability
```{r echo=FALSE}
interESMall <- data.frame(individual = validityESM_ALL$individual, thetaALL = validityESM_ALL$theta, rawALL = validityESM_ALL$rawdecisionsALL)
interESM250 <- data.frame(individual = validityESM_subset$individual, theta250 = validityESM_subset$theta, raw250 = validityESM_subset$rawdecisions250)

interESM <- merge(interESMall,interESM250)

interESMtheta <- cor(interESM$thetaALL,interESM$theta250)
interESMraw <- cor(interESM$rawALL,interESM$raw250)
interESMtheta
interESMraw

# plot(interESM$thetaALL,interESM$theta250)
# plot(interESM$rawALL,interESM$raw250)
writeProbSol <- data.frame(theta1=interESM$thetaALL,theta2=interESM$theta250,raw1=interESM$rawALL,raw2=interESM$raw250)
write.csv(writeProbSol,"ESM2015plots.csv")

cocor.indep.groups(interESMtheta, interESMraw, nrow(interESM), nrow(interESM))@fisher1925

```



## SEE 2015: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('SEE2015alljudgements.csv', header=T, stringsAsFactors=F)

schoolA <- decisions[decisions$School=="5403",2:4]
schoolB <- decisions[decisions$School=="4052",2:4]
schoolC <- decisions[decisions$School=="8454038",2:4]



```


### SEE 2014: SchoolA  {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(schoolA$Candidate.Chosen,schoolA$Candidate.Not.Chosen))
length(unique(schoolA$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = schoolA %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(schoolA$Candidate.Chosen,schoolA$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=schoolA$Candidate.Chosen, id2=schoolA$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawschoolA <- mod1$effects$N1/mod1$effects$Ntot
scoresschoolA <- cbind(mod1$effects[,c(1,9)],rawschoolA)
colnames(scoresschoolA) <- c("individual", "thetaA", "rawA")
cor(scoresschoolA$thetaA,scoresschoolA$rawA)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresschoolA
colnames(jq1)[1] <- "id1"
jq2 <- scoresschoolA
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

### SEE 2014: schoolB   {.tabset}



Number of judges =
```{r echo=FALSE}
players <- unique(c(schoolB$Candidate.Chosen,schoolB$Candidate.Not.Chosen))
length(unique(schoolB$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = schoolB %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(schoolB$Candidate.Chosen,schoolB$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=schoolB$Candidate.Chosen, id2=schoolB$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawschoolB <- mod1$effects$N1/mod1$effects$Ntot
scoresschoolB <- cbind(mod1$effects[,c(1,9)],rawschoolB)
colnames(scoresschoolB) <- c("individual", "thetaB", "rawB")
cor(scoresschoolB$thetaB,scoresschoolB$rawB)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresschoolB
colnames(jq1)[1] <- "id1"
jq2 <- scoresschoolB
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



### SEE 2014: schoolC   {.tabset}


Number of judges =
```{r echo=FALSE}
players <- unique(c(schoolC$Candidate.Chosen,schoolC$Candidate.Not.Chosen))
length(unique(schoolC$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = schoolC %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(schoolC$Candidate.Chosen,schoolC$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=schoolC$Candidate.Chosen, id2=schoolC$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawschoolC <- mod1$effects$N1/mod1$effects$Ntot
scoresschoolC <- cbind(mod1$effects[,c(1,9)],rawschoolC)
colnames(scoresschoolC) <- c("individual", "thetaC", "rawC")
cor(scoresschoolC$thetaC,scoresschoolC$rawC)
```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresschoolC
colnames(jq1)[1] <- "id1"
jq2 <- scoresschoolC
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



### SEE part 2: Reliability and validity stuff
```{r echo=FALSE}
SEE_validity <- merge(scoresschoolA,scoresschoolB)
SEE_validity <- merge(SEE_validity,scoresschoolC)
SEE_validity <- merge(SEE_validity,SEE_experts)
SEE_validity <- merge(SEE_validity,SEE_achievement)

SEE_correl <- cor(SEE_validity[,2:9])
thetaAB <- SEE_correl[1,3]
thetaAC <- SEE_correl[1,5]
thetaBC <- SEE_correl[3,5]
rawAB <- SEE_correl[2,4]
rawAC <- SEE_correl[2,6]
rawBC <- SEE_correl[4,6]

round(SEE_correl,3)


cocor.indep.groups(thetaAB, rawAB, nrow(SEE_validity), nrow(SEE_validity))@fisher1925
cocor.indep.groups(thetaAC, rawAC, nrow(SEE_validity), nrow(SEE_validity))@fisher1925
cocor.indep.groups(thetaBC, rawBC, nrow(SEE_validity), nrow(SEE_validity))@fisher1925

```

SEE all peer judgements together


Number of judges =
```{r echo=FALSE}
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r , include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```


Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
rawdecisions <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(rawdecisions==1)
zeros <- sum(rawdecisions==0)
ones
zeros
(ones+zeros)/length(rawdecisions)
scoresdecisions <- cbind(mod1$effects[,c(1,9)],rawdecisions)
colnames(scoresdecisions) <- c("individual", "thetaPeer", "rawPeer")
cor(scoresdecisions$thetaPeer,scoresdecisions$rawPeer)
```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresdecisions
colnames(jq1)[1] <- "id1"
jq2 <- scoresdecisions
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  


###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scoresdecisions), nrow(scoresdecisions))@fisher1925
```


Validity, peer vs expert thetas then raw
```{r echo=FALSE}


SEE_validity <- merge(SEE_validity,scoresdecisions)

SEEtheta <- cor(SEE_validity$theta,SEE_validity$thetaPeer)
SEEraw <-  cor(SEE_validity$raw,SEE_validity$rawPeer)

SEEtheta
SEEraw
cocor.indep.groups(SEEtheta, SEEraw, nrow(SEE_validity), nrow(SEE_validity))@fisher1925

```


Validity by achievement data, younger students (thetas then raw) then older students (thetas then raw)
```{r echo=FALSE}


SEE_younger <- SEE_validity[SEE_validity$year<9,]
nrow(SEE_younger)
SEE_older <- SEE_validity[SEE_validity$year>8,]
nrow(SEE_older)

mean(SEE_younger$thetaPeer[SEE_younger$level==1])
mean(SEE_younger$thetaPeer[SEE_younger$level==2])
wilcoxo <- wilcox.test(SEE_younger$thetaPeer ~ SEE_younger$level)
zstato <-qnorm(wilcoxo$p.value/2)
wilcoxo
zstato

mean(SEE_younger$rawPeer[SEE_younger$level==1])
mean(SEE_younger$rawPeer[SEE_younger$level==2])
wilcoxy <- wilcox.test(SEE_younger$rawPeer ~ SEE_younger$level)
zstaty <-qnorm(wilcoxy$p.value/2)
wilcoxy
zstaty

cor(SEE_older$thetaPeer,SEE_older$grade, method="spearman")
cor(SEE_older$rawPeer,SEE_older$grade, method="spearman")
#identical

```

## Alevel BERJ 2015 (imperfect)  {.tabset}


```{r include=FALSE}

decisions <- read.csv('BERJ2019decisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```




### Basic stuff 

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r  include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,10)],raw)
cor(scores$theta,scores$raw)

```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores#[,c(1,4,5)]
colnames(jq1)[1] <- "id1"
jq2 <- scores#[,c(1,4,5)]
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

### Validity: regression, theta then raw
```{r echo=FALSE}
#first some data prep

ofqual <- read.csv('BSRJ2016ofqualdata.csv', header=T)


#BELOW SEEMS OBSELETE, NOT SURE WHAT HAPPENED
#grade <- individual
#individual <- rep(0,nrow(scores))
#year <- individual

#script identifiers are messy in this data set so need to sort them out so we can create mean scores for each A-level candidate across the different questions they did
#for (i in 1:nrow(scores)) {
#  individual[i] <- as.numeric(strsplit(as.character(scores[i,1]),"_")[[1]][1])
#   year[i] <- as.numeric(strsplit(as.character(scores[i,1]),"_")[[1]][2])
#    grade[i] <- strsplit(as.character(scores[i,1]),"_")[[1]][3]
#}

#scoresBERJ <- cbind(scores[,2:3],individual)

scoresBERJindividuals <- ofqual %>%
 group_by(individual) %>%
  summarise(theta = mean(estimate), raw = mean(raw)) %>% as.data.frame

scoresBERJindividuals <- merge(scoresBERJindividuals,ofqual[,c(1,3,4)]) 


```


```{r echo=FALSE}

fitBERJtheta <- lm(theta ~ year + grade, data=scoresBERJindividuals)
summary(fitBERJtheta) # show results
lm.beta(fitBERJtheta)
confint(fitBERJtheta)


fitBERJraw <- lm(raw ~ year + grade, data=scoresBERJindividuals)
summary(fitBERJraw) # show results
lm.beta(fitBERJraw)
confint(fitBERJraw)
```

## BERJ Study 2: perfect scripts {.tabset}



```{r include=FALSE}

decisions <- read.csv('BERJperfect.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```




### Basic stuff

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresperfect <- cbind(mod1$effects[,c(1,10)],raw)
cor(scoresperfect$theta,scoresperfect$raw)
colnames(scoresperfect) <- c("individual","thetaperfect","rawperfect")

```


Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresperfect
colnames(jq1)[1] <- "id1"
jq2 <- scoresperfect
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scoresperfect), nrow(scoresperfect))@fisher1925
```

### Analysis and tests

```{r echo=FALSE}
#code below now obselete
#write.csv(scoresBERJ3, "BERJ2016_perfect_imperfect.csv")


#year <- rep(0,nrow(scoresperfect))
#qn <- year
#script identifiers are messy in this data set so need to sort them out so we can create mean scores for each A-level candidate across the different questions they did
#for (i in 1:nrow(scoresperfect)) {
#   year[i] <- as.numeric(strsplit(as.character(scoresperfect[i,1]),"Q")[[1]][1])
#    qn[i] <- as.numeric(strsplit(as.character(scoresperfect[i,1]),"Q")[[1]][2])
#}

#scoresBERJ2 <- cbind(scoresperfect[,2:3], year, qn)

#scoresBERJ3 <- scoresBERJ2 %>%
# group_by(year,qn) %>%
#  summarise(theta = mean(theta), raw = mean(raw)) %>% as.data.frame

#individual = rep("Q",nrow(scoresBERJ3))
#for (i in 1:nrow(scoresBERJ3)) {
#   individual[i] <- paste(scoresBERJ3[i,1],scoresBERJ3[i,2],sep="Q")
#}


#scoresBERJ3 <- cbind(scoresBERJ3,individual) 
#scoresBERJ3 <- merge(scoresBERJ3,scoresperfect)
scoresBERJ3 <- read.csv("BERJ2016_perfect_imperfect.csv", header = T)

corperfecttheta <- cor(scoresBERJ3$theta,scoresBERJ3$thetaperfect)
corperfectraw <- cor(scoresBERJ3$raw,scoresBERJ3$rawperfect)
corperfecttheta
corperfectraw

cocor.indep.groups(corperfecttheta, corperfectraw, nrow(scoresBERJ3), nrow(scoresBERJ3))@fisher1925


```

```{r echo=FALSE}

fitBERJperfecttheta <- lm(thetaperfect ~ year, data=scoresBERJ3)
summary(fitBERJperfecttheta) # show results
lm.beta(fitBERJperfecttheta)
confint(fitBERJperfecttheta)


fitBERJperfectraw <- lm(raw ~ year, data=scoresBERJ3)
summary(fitBERJperfectraw) # show results
lm.beta(fitBERJperfectraw)
confint(fitBERJperfectraw)
```



## NOMAD peer assessment {.tabset}



```{r include=FALSE}

decisions <- read.csv('NOMAD2017_peerjudgements.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))


validityNOMAD <- read.csv('NOMAD2017_validity.csv', header=T)

```




### Student judgements

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresNOMAD <- cbind(mod1$effects[,c(1,10)],raw)
cor(scoresNOMAD$theta,scoresNOMAD$raw)


```



Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresNOMAD
colnames(jq1)[1] <- "id1"
jq2 <- scoresNOMAD
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scoresNOMAD), nrow(scoresNOMAD))@fisher1925
```


### Validity
```{r echo=FALSE}

colnames(validityNOMAD)[1] <- "individual"

NOMAD <- merge(scoresNOMAD,validityNOMAD)
NOMAD <- NOMAD[complete.cases(NOMAD), ]


NOMADcor <- round(cor(NOMAD[,2:10], use="complete.obs"),3)

NOMADtheta <- mean(NOMADcor[1,3:9])
NOMADraw <- mean(NOMADcor[2,3:9])
NOMADdep <- NOMADcor[1,2]
NOMADtheta
NOMADraw

cocor.dep.groups.overlap(NOMADraw,NOMADraw,NOMADdep,nrow(NOMAD))@steiger1980


```




## BERJ 2019 grid algebra {.tabset}



```{r include=FALSE}

decisions <- read.csv('BERJ2019decisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

#get achievement data
BERJachieve2019 = read.delim("BERJ2019achievement.txt", header = TRUE)

```




### CJ reliability

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )


```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresBERJ2019 <- cbind(mod1$effects[,c(1,10)],raw)
cor(scoresBERJ2019$theta,scoresBERJ2019$raw)


```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresBERJ2019
colnames(jq1)[1] <- "id1"
jq2 <- scoresBERJ2019
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```

Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
highest<-0
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))

      if (round(ir[i,3],2)==.75 && round(ir[i,2],2)==.75){
      highest_theta <- cbind(modg12$theta.x,modg12$theta.y)
      highest_raw <- cbind(raw1,raw2)
      
      }
        
      print(i)
    } # end of for i in 1:iterations loop

#writeAlgebra2 <- data.frame(theta1=modg12$theta.x,theta2=modg12$theta.y,raw1=raw1,raw2=raw2)
#write.csv(writeAlgebra2,"BERJ2019.csv")
```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scoresBERJ2019), nrow(scoresBERJ2019))@fisher1925

#cor(highest_theta)
#cor(highest_raw)
# plot(highest_theta)
# plot(highest_raw)

#write.csv(cbind(highest_theta,highest_raw),"BERJ2019_plot.csv")


```


### regression modelling
```{r echo=FALSE}

data <- merge(scoresBERJ2019,BERJachieve2019)

### the fact that there is a missing data point in the raven causes problem later on, so I will exclude this participant completely now

data$participant_exclude = 0
data$participant_exclude[data$individual==91] = 1
data$participant_exclude = as.factor(data$participant_exclude)

data2 = subset(data, data$participant_exclude == 0)





```


running a quick linear model on the CJ estimates and raw scores with group as a predictor
```{r echo=FALSE}



CJlinearmodel <- lm(CJ_estimate ~ group, data = data)
summary(CJlinearmodel)

thetalinearmodel <- lm(theta ~ group, data = data)
summary(thetalinearmodel)

rawlinearmodel <- lm(raw ~ group, data = data)
summary(rawlinearmodel)


```


theta's model checking
```{r }

###Now checking whether we actually need to do a multi-level model. In other words does our data vary across contexts, here the school of the participants.

interceptOnly <- gls(theta ~1, data = data2, method = "ML")
summary(interceptOnly)

###the 1 in the equation denotes the intercept
##now computing a model where the intercepts are allowed to vary across contexts

randomInterceptOnly <- lme(theta ~1, data = data2, random = ~1|school_recoded, method = "ML")
summary(randomInterceptOnly)

### the BIC values do go down which indicates an improved fit of the model. Now comparing the 2 models statistically

anova(interceptOnly, randomInterceptOnly)
### the results show that the model allowing the intercepts to vary across schools is significanlty better ((1), p < .001), hence we need to model this variablity.



```


raw scores model checking
```{r }

###Now checking whether we actually need to do a multi-level model. In other words does our data vary across contexts, here the school of the participants.

interceptOnlyraw <- gls(raw ~1, data = data2, method = "ML")
summary(interceptOnlyraw)

###the 1 in the equation denotes the intercept
##now computing a model where the intercepts are allowed to vary across contexts

randomInterceptOnlyraw <- lme(raw ~1, data = data2, random = ~1|school_recoded, method = "ML")
summary(randomInterceptOnlyraw)

### the BIC values do go down which indicates an improved fit of the model. Now comparing the 2 models statistically

anova(interceptOnlyraw, randomInterceptOnlyraw)
### the results show that the model allowing the intercepts to vary across schools is significanlty better ((1), p < .001), hence we need to model this variablity.



```

theta's model
```{r}

# create a model adding in the group effect, before adding in covariates
randomInterceptTeachingGroup <- lme(theta ~ group_recode, data=data2, random = ~1|school_recoded, method="ML")
summary(randomInterceptTeachingGroup)

# compare model with group to model without group, where both have random intercepts
anova(randomInterceptTeachingGroup,randomInterceptOnly)


# now I'll add the covariates (including maths anxiety)
randomInterceptTeachingGroupCovariates <- lme(theta ~ group_recode + Ravens_A_C + Numerical_op + Written_expression + Anxiety_total, data=data2, random = ~1|school_recoded, method="ML")
summary(randomInterceptTeachingGroupCovariates)

# compare the model with covariates to the one without, where both have random intercepts
anova(randomInterceptTeachingGroup,randomInterceptTeachingGroupCovariates)

# now we want the slopes to vary (i.e. the slopes might vary between schools)
randomInterceptAndSlopeTeachingGroupCovariates <- lme(theta ~ group_recode + Ravens_A_C + Numerical_op + Written_expression + Anxiety_total, data=data2, random = ~group_recode|school_recoded, method="ML")
summary(randomInterceptAndSlopeTeachingGroupCovariates)

# compare the model with slopes varying between schools with the one where slopes don't vary
anova(randomInterceptAndSlopeTeachingGroupCovariates,randomInterceptTeachingGroupCovariates)

# so our final model is:
summary(randomInterceptAndSlopeTeachingGroupCovariates)

```


raw scores model
```{r}

# create a model adding in the group effect, before adding in covariates
randomInterceptTeachingGroupraw <- lme(raw ~ group_recode, data=data2, random = ~1|school_recoded, method="ML")
summary(randomInterceptTeachingGroupraw)

# compare model with group to model without group, where both have random intercepts
anova(randomInterceptTeachingGroupraw,randomInterceptOnlyraw)


# now I'll add the covariates (including maths anxiety)
randomInterceptTeachingGroupCovariatesraw <- lme(raw ~ group_recode + Ravens_A_C + Numerical_op + Written_expression + Anxiety_total, data=data2, random = ~1|school_recoded, method="ML")
summary(randomInterceptTeachingGroupCovariatesraw)

# compare the model with covariates to the one without, where both have random intercepts
anova(randomInterceptTeachingGroupraw,randomInterceptTeachingGroupCovariatesraw)

# now we want the slopes to vary (i.e. the slopes might vary between schools)
randomInterceptAndSlopeTeachingGroupCovariatesraw <- lme(raw ~ group_recode + Ravens_A_C + Numerical_op + Written_expression + Anxiety_total, data=data2, random = ~group_recode|school_recoded, method="ML")
summary(randomInterceptAndSlopeTeachingGroupCovariatesraw)

# compare the model with slopes varying between schools with the one where slopes don't vary
anova(randomInterceptAndSlopeTeachingGroupCovariatesraw,randomInterceptTeachingGroupCovariatesraw)

# so our final model is:
summary(randomInterceptAndSlopeTeachingGroupCovariatesraw)

```




## RME 2019 derivatives {.tabset}



```{r include=FALSE}

decisions <- read.csv('RME2019decisions.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

#get achievement data
RMEachieve2019 = read.csv("RME2019achieve.csv", header = TRUE)

```




### CJ reliability

Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
sum(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
median(rangeS$total)
sort(rangeS$total)
```


```{r include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )


```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```

Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scoresRME2019 <- cbind(mod1$effects[,c(1,10)],raw)
cor(scoresBERJ2019$theta,scoresBERJ2019$raw)


```




Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scoresRME2019
colnames(jq1)[1] <- "id1"
jq2 <- scoresRME2019
colnames(jq2)[1] <- "id2"

jq <- merge(df,jq1)
colnames(jq)[4:5] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[6:7] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```

Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2))  
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)


expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)

jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  

###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```


Inter-rater reliability, theta  then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop

writeCalculus5 <- data.frame(theta1=modg12$theta.x,theta2=modg12$theta.y,raw1=raw1,raw2=raw2)
#write.csv(writeCalculus5,"RME2019_plot.csv")
cor(writeCalculus5$theta1,writeCalculus5$theta2)
cor(writeCalculus5$raw1,writeCalculus5$raw2)
```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scoresRME2019), nrow(scoresRME2019))@fisher1925
```

### Validity and tests

```{r echo=FALSE}

RME2019 <- merge(scoresRME2019, RMEachieve2019)
#write.csv(RME2019,"RME2019jasp.csv")

RMEcortheta2019 <- rcorr(as.matrix(RME2019[,c(2,4,5,6,7)]))
RMEcortheta2019


RMEcorraw2019 <- rcorr(as.matrix(RME2019[,c(3,4,5,6,7)]))
RMEcorraw2019


```

Theta Bayes
```{r echo=FALSE}


model.data = list('Num_op'=(RME2019$Num_op -mean(RME2019$Num_op))/sd(RME2019$Num_op),
                  'DerivCJ'=(RME2019$theta - mean(RME2019$theta))/sd(RME2019$theta),
                  'group'=(RME2019$group - mean(RME2019$group))/sd(RME2019$group),
                  'N'=dim(RME2019)[1])


# model.data = list('Num_op'=(Y11$Num_op),
#                   'DerivCJ'=(Y11$Derivatives_CJ),
#                   'group'=(Y11$group),
#                   'N'=dim(Y11)[1])



#M <- jags.model('RME2019_linear_regression_nuff_y11-reduced.jags',
                #data=model.data,
                #n.chains = 3)

#update(M, 50000)

#S2 <- coda.samples(M, 
#                  variable.names = c('alpha', 
#                                     'beta.Num_op',
#                                     'beta.group'),
#                  50000)

#summary(S2)

```

Unstandardised coefficients: numop then group
```{r echo=FALSE}

alphathetastandard <- -0.0001237 * sd(RME2019$theta)
alphathetastandard

numopthetastandard <- 0.1830 * sd(RME2019$theta)/sd(RME2019$Num_op)
numopthetastandard

groupthetastandard <- -0.0673990 * sd(RME2019$theta)/sd(RME2019$group)
groupthetastandard
```



Raw Bayes
```{r echo=FALSE}


model.data2 = list('Num_op'=(RME2019$Num_op -mean(RME2019$Num_op))/sd(RME2019$Num_op),
                  'DerivCJ'=(RME2019$raw - mean(RME2019$raw))/sd(RME2019$raw),
                  'group'=(RME2019$group - mean(RME2019$group))/sd(RME2019$group),
                  'N'=dim(RME2019)[1])


# model.data = list('Num_op'=(Y11$Num_op),
#                   'DerivCJ'=(Y11$Derivatives_CJ),
#                   'group'=(Y11$group),
#                   'N'=dim(Y11)[1])



#M2 <- jags.model('RME2019_linear_regression_nuff_y11-reduced.jags',
 #               data=model.data2,
#                n.chains = 3)

#update(M2, 50000)

#S3 <- coda.samples(M2, 
#                  variable.names = c('alpha', 
#                                     'beta.Num_op',
#                                     'beta.group'),
#                  50000)

#summary(S3)


#mean(c(.839,.881))
#mean(c(.990,.992))
#mean(c(.821,.927))
#mean(c(.836,.925))
```


Unstandardised coefficients: numop then group
```{r echo=FALSE}



numoprawstandard <- .3326 * sd(RME2019$raw)/sd(RME2019$Num_op)
numoprawstandard

grouprawstandard <- -.06630 * sd(RME2019$raw)/sd(RME2019$group)
grouprawstandard
```



## PROOF CONCEPTIONS ESM2020: analysis  {.tabset}


```{r include=FALSE}

decisions <- read.csv('ESM2020RawDecisionData.csv', header=T, stringsAsFactors=F)
#Create a unique factor level for each candidate
players <- unique(c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen))

```






Number of judges =
```{r echo=FALSE}
length(unique(decisions$Judge))
```

List of number of judgements per judge =
```{r echo=FALSE}
rangeJ = decisions %>% #this is dplyr package stuff, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeJ$total)
```

Number of scripts =
```{r echo=FALSE}
allscriptoccurrences <- c(decisions$Candidate.Chosen,decisions$Candidate.Not.Chosen)
length(unique(allscriptoccurrences))
allscriptoccurrences <- as.data.frame(allscriptoccurrences)
```


List of number of judgements per script =
```{r echo=FALSE}
rangeS = allscriptoccurrences %>% 
  group_by(allscriptoccurrences) %>%
  summarise(total = n()) %>% as.data.frame
sort(rangeS$total)
median(rangeS$total)
sum(rangeS$total)/2

```


```{r, include=FALSE}
#### Fit B-T ####
df <- data.frame(id1=decisions$Candidate.Chosen, id2=decisions$Candidate.Not.Chosen, result=1)
df$id1 <- factor(df$id1,levels=players)
df$id2 <- factor(df$id2,levels=players)
mod1 <- sirt::btm(df , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
#write.csv(mod1$effects,"sirtTHETAs.csv")
```

SSR=
```{r echo=FALSE}
round(mod1$mle.rel,3)
```



Count of 1s and 0s in raw, Correlation of theta and raw
```{r echo=FALSE}
raw <- mod1$effects$N1/mod1$effects$Ntot
ones <- sum(raw==1)
zeros <- sum(raw==0)
ones
zeros
(ones+zeros)/length(raw)
scores <- cbind(mod1$effects[,c(1,3,4,10)],raw)
cor(scores$theta,scores$raw)

```

Judgement quality, theta then raw (then raw matches)
```{r echo=FALSE}

jq1 <- scores[,c(1,4,5)]
colnames(jq1)[1] <- "Candidate.Chosen"
jq2 <- scores[,c(1,4,5)]
colnames(jq2)[1] <- "Candidate.Not.Chosen"

jq <- merge(decisions,jq1)
colnames(jq)[6:7] <- c("theta1","raw1")

jq <- merge(jq,jq2)
colnames(jq)[8:9] <- c("theta2","raw2")

jq_theta <- as.numeric(jq$theta1 > jq$theta2)
jq_raw <- as.numeric(jq$raw1 > jq$raw2)
jq_raw_match <- as.numeric(jq$raw1 == jq$raw2)

mean(jq_theta)
mean(jq_raw)
mean(jq_raw_match)


```


Probability measure, quantile then correlation of FS and RS probabilities
```{r echo=FALSE}
expTheta <- exp(abs(jq$theta1-jq$theta2)) 
jq$probTheta <- (expTheta)/(1+expTheta) #we only want the probability that either wins
# plot(1:nrow(jq),sort(jq$probTheta), pch = 19, col = "black", cex = .2)
quantile(jq$probTheta)
jq_fractions1 <- jq[jq$probTheta>.7,]

expRaw <- exp(jq$raw1-jq$raw2) 
jq$probRaw <- abs((expRaw)/(1+expRaw)-.5) #we only want the probability that either wins
## plot(1:nrow(jq),sort(jq$probRaw), pch = 19, col = "black", cex = .2)
quantile(jq$probRaw)

cor(jq$probTheta,jq$probRaw)

```


Pairings measure, quantile then correlation of pairing differences and probabilities
```{r echo=FALSE}

jq$theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(jq$theta_diff)
cor(jq$theta_diff,jq$probTheta)



jq$raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(jq$raw_diff)
cor(jq$raw_diff,jq$probRaw)



```  



Pairings measure
```{r echo=FALSE}

theta_diff <- abs(scale(jq$theta1)[,1]-scale(jq$theta2)[,1])
quantile(theta_diff)

raw_diff <- abs(scale(jq$raw1)[,1]-scale(jq$raw2)[,1])
quantile(raw_diff)

jq_fractions1 <- cbind(jq[,1:3],raw_diff=raw_diff)
colnames(jq_fractions1)[1:2] <- c("Candidate.Chosen", "Candidate.Not.Chosen")

jq_fractions1 <- jq_fractions1[order(jq_fractions1$raw_diff),]

jq_fractions1 <- jq_fractions1[134:400,]

#write.csv(jq_fractions1,"PMEfractionsdecisionsFARPAIRINGSONLY.csv")

```  




###Judge misfits

```{r include=FALSE}
#calculate judge infit
length(unique(decisions$Judge))
jin = data.frame(Candidate.Chosen=mod1$effects$individual, chosen_theta = mod1$effects$theta ) #get just the cols we want from mod1$effects
jin2 = merge(decisions,jin) #now we have the thetas for Candidate.Chosen
jin3 = data.frame(Candidate.Not.Chosen=mod1$effects$individual, notchosen_theta = mod1$effects$theta ) 
jin4 = merge(jin2,jin3)
#glimpse(jin4)

pCbeatsNC = exp(jin4$chosen_theta - jin4$notchosen_theta) / (1+exp(jin4$chosen_theta - jin4$notchosen_theta)) #formula 1a from Pollitt 2012; pCbeatsNC is prob that Chosen beats Not.Chosen
pNCbeatsC = 1 - pCbeatsNC #this is prob that Not.Chosen beats Chosen; and wierldy for our NMM case it is also what Pollitt calls the residual
jin5 = as.data.frame(cbind(jin4,pCbeatsNC,pNCbeatsC))
#glimpse(jin5)

#collate into a neat table with one row per judge
finaltable = jin5 %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(Judge) %>%
  summarise(total = sum(pCbeatsNC), average = mean(pCbeatsNC)) %>% as.data.frame
#glimpse(finaltable)
misfit_thresh = mean(finaltable$average) + 2 * sd(finaltable$average)
misfitsonlytable <- finaltable[finaltable$average > misfit_thresh,] 

```

Number of misfits=
```{r echo=FALSE}
nrow(misfitsonlytable)
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
misfitsonlytable
```


###Script misfits

```{r include=FALSE}
#calculate script infit
scrin <- data.frame(candidate = c(jin5$Candidate.Chosen, jin5$Candidate.Not.Chosen),
                    theta = c(jin5$chosen_theta,jin5$notchosen_theta),
                    othertheta = c(jin5$notchosen_theta,jin5$chosen_theta),
                    pWin = c(jin5$pCbeatsNC,jin5$pNCbeatsC),
                    pLose = c(jin5$pNCbeatsC, jin5$pCbeatsNC ),
                    observed = c(rep(1,nrow(jin5)),rep(0,nrow(jin5))))

residual = scrin$observed - scrin$pWin #equation 9 in Pollitt 2012
pWinTIMESpLose = scrin$pWin * scrin$pLose
sqstdres = residual^2 / pWinTIMESpLose  #equation 10 in Pollitt 2012

scrin = as.data.frame(cbind(scrin,residual,pWinTIMESpLose,sqstdres))
#glimpse(scrin)

#collate into a neat table with one row per candidate
scripttable = scrin %>% #this is dplyr package studd, and %>% means pipe through to the next command
  group_by(candidate) %>%
  summarise(wms = sum(pWinTIMESpLose * sqstdres) / sum(pWinTIMESpLose)) %>% as.data.frame
scripttable <- scripttable[ order(scripttable$wms),]
script_misfit_thresh = mean(scripttable$wms) + 2 * sd(scripttable$wms)
numscriptmisfits <- nrow(scripttable[scripttable$wms > script_misfit_thresh,,])
#write.csv(scripttable[ order(scripttable$wms),],"scriptmisfits.csv")

```

Number of misfits=
```{r echo=FALSE}
numscriptmisfits
```


Misfit threshold (2 SDs above mean) = 
```{r echo=FALSE}
script_misfit_thresh
```


Table of misfits (shows '0 rows' if na)
```{r echo=FALSE}
scripttable[scripttable$wms > script_misfit_thresh,,]
```



Inter-rater, theta then raw
```{r include=FALSE}
#inter-rater
iterations = 100
ir = data.frame(iteration = rep(0,iterations), theta = rep(0,iterations), raw = rep(0,iterations), spearman_theta  = rep(0,iterations), spearman_raw  = rep(0,iterations), num_cand = rep(0,iterations))

ip = as.data.frame(matrix(data=0,nrow=nrow(mod1$effects),ncol=2*iterations))
colnames(ip) = as.character(c(1:(2*iterations)))


noj = length(unique(decisions$Judge)) #number of judges
judges = data.frame(row = 1:noj, Judge = unique(decisions$Judge), rand = rep(0,noj), group = rep(0,noj))

for(i in 1:iterations)
    {
      ir[i,1] = i # fill iteration column

      judges$rand = runif(noj, -1, 1)  #randomly split judges
      judges <- judges[order(judges$rand),]
      judges$row = 1:noj
      judges$group = 2
      judges$group[1:(noj/2)] <-1

      groups = merge(decisions,judges) #now split judgements
      g1 = groups[groups$group==1,]
      g2 = groups[groups$group==2,]
      players1 <- unique(c(g1$Candidate.Chosen,g1$Candidate.Not.Chosen))
      players2 <- unique(c(g2$Candidate.Chosen,g2$Candidate.Not.Chosen))
      length(players1)
      length(players2)


      df1 <- data.frame(id1=g1$Candidate.Chosen, id2=g1$Candidate.Not.Chosen, result=1)
      df1$id1 <- factor(df1$id1,levels=players)
      df1$id2 <- factor(df1$id2,levels=players)
      modg1 <- sirt::btm(df1 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw1 <- modg1$effects$N1/modg1$effects$Ntot
      #summary(modg1)

      df2 <- data.frame(id1=g2$Candidate.Chosen, id2=g2$Candidate.Not.Chosen, result=1)
      df2$id1 <- factor(df2$id1,levels=players)
      df2$id2 <- factor(df2$id2,levels=players)
      modg2 <- sirt::btm(df2 , maxit=400 , fix.eta=0 , ignore.ties=TRUE )
      raw2 <- modg2$effects$N1/modg2$effects$Ntot
      #summary(modg2)

      modg12 = merge(modg1$effects, modg2$effects, by="individual") #bodge in case different number of candidates in each rank

      ir[i,2] =  cor(modg12$theta.x,modg12$theta.y, method="pearson") # fill correlation column
      ir[i,3] =  cor(raw1,raw2, method="pearson") # fill correlation column
      ir[i,4] =  cor(modg12$theta.x,modg12$theta.y, method="spearman") # fill correlation column
      ir[i,5] =  cor(raw1,raw2, method="spearman") # fill correlation column
      ir[i,6] = nrow(modg12)

      ip[,2*i-1] = c(modg12$theta.x, rep(0,nrow(mod1$effects)-nrow(modg12)))
      ip[,2*i] = c(modg12$theta.y, rep(0,nrow(mod1$effects)-nrow(modg12)))



      print(i)
    } # end of for i in 1:iterations loop


```


```{r echo=FALSE}
round(median(ir$theta),3)
round(median(ir$raw),3)
round(median(ir$spearman_theta),3)
round(median(ir$spearman_raw),3)

cocor.indep.groups(median(ir$theta), median(ir$raw), nrow(scores), nrow(scores))@fisher1925
```

Criterion validity
```{r include=FALSE}
achievement <- read.csv('ESM2020RawValidityData.csv', header=T)
df <- merge(achievement,scores)

```

Correlation with 7-items, theta then raw
```{r echo=FALSE}
theta_items7 <- cor(df$theta,df$X7QTotal)
raw_items7 <- cor(df$raw,df$X7QTotal)
theta_items7 
raw_items7
cocor.indep.groups(theta_items7, raw_items7, nrow(df), nrow(df))@fisher1925

```
Correlation with module scores, theta then raw
```{r echo=FALSE}
df3 <- df[is.na(df$Module.Score)==F,]

theta_mod <- cor(df3$theta,df3$Module.Score)
raw_mod <- cor(df3$raw,df3$Module.Score)
theta_mod 
raw_mod
cocor.indep.groups(theta_mod, raw_mod, nrow(df3), nrow(df3))@fisher1925

```
